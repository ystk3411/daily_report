## 取り組んだ課題一覧
* プロを目指す人のためのRuby入門を読むの続き
## 分かったこと
第八章
* モジュール
  * ```extend モジュール名```でモジュールのメソッドをクラスメソッドとして追加する。
  * ```クラス名.include/extend モジュール名```でもモジュールを呼び出せる。
  * モジュールのメソッド内でミックスイン先のインスタンス変数の読み書きができる。しかしこれは設計として推奨されない。
  * クラスの名前の衝突を避けるためにモジュール内にクラスを作成する名前空間としてモジュールが使われるケースがある。```モジュール名：：クラス名```で参照できる。
  * 名前空間つきのクラスを定義する方法は二通りある。
    ```ruby:code
    #入れ子にして書くケース
    module SampleModule
     class SampleClass
      ＃処理
     end
    end
    ```
    ```ruby:code
    #入れ子なしのケース
    class SampleModule::SampleClass
    　　＃処理
    end
    ```
  第九章
* 例外処理
    * シンプルな例外処理の構文。実際のプログラムではあまり好ましくない
    ```ruby:code
    begin
      #例外が起きうる処理
    rescue
      #例外が発生した際の処理
    end
    ```
    * ```message```メソッドで例外発生時のエラーメッセージを表示する。
    ```ruby:code
    begin
      #例外が起きうる処理
    rescue => 例外オブジェクトを格納する変数（exeptionの省略形のeやexが使われることが多い）
      #例外が発生した際の処理
      puts e.message
    end
    ```
    * ```backtrace```メソッドでバックトレース情報（メソッドの呼び出し履歴）表示する。
  　　　　```ruby:code
    begin
      #例外が起きうる処理
    rescue => 例外オブジェクトを格納する変数（exeptionの省略形のeやexが使われることが多い）
      #例外が発生した際の処理
      puts e.backtrace
    end
    ```
    * 例外オブジェクトのクラスが一致した場合のみ例外を捕捉することができる。
    ```ruby:code
    begin
      #例外が起きうる処理
    rescue 例外クラス（ZeroDivisonError、NoMethodError等）
      #例外が発生した際の処理
      #rescue節は複数記載可能
      puts e.backtrace
    end
    ```
    * ```raise エラーメッセージ```メソッドで意図的に例外を発生させることができる。
    * ```full_message```メソッドで例外のクラス名、エラーメッセージ、バックトレースを一度に取り出せる。
    * ```ensure```節を組み込むことによって例外の有無にかかわらず行う処理を加えられる。
    ```ruby:code
    begin
      #例外が起きうる処理
    rescue 
      #例外が発生した際の処理
    ensure
      #例外の有無にかかわらず行われる処理
    end
    ```
    
    

## 次やること
*  プロを目指す人のためのRuby入門を読むの続き
## 感じたこと
*  名前空間のところが途中ややこしかった。
 
## 学習時間
今日：7.0h
合計：203.0h
